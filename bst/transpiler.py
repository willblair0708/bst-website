#!/usr/bin/env python3
"""
Bastion λ-Trial: YAML-to-Python Transpiler

Converts declarative clinical trial YAML protocols into executable Python test harnesses
for simulation, validation, and regulatory compliance checking.
"""

import yaml
import json
import jsonschema
from pathlib import Path
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
import argparse
import sys

@dataclass
class TranspilerConfig:
    """Configuration for the YAML-to-Python transpiler."""
    schema_path: Path
    output_dir: Path
    include_tests: bool = True
    include_validation: bool = True
    include_simulation: bool = True

class ProtocolTranspiler:
    """Main transpiler class for converting YAML protocols to Python."""
    
    def __init__(self, config: TranspilerConfig):
        self.config = config
        self.schema = self._load_schema()
        
    def _load_schema(self) -> Dict[str, Any]:
        """Load the JSON schema for validation."""
        with open(self.config.schema_path, 'r') as f:
            return json.load(f)
    
    def validate_protocol(self, protocol: Dict[str, Any]) -> bool:
        """Validate protocol against JSON schema."""
        try:
            jsonschema.validate(protocol, self.schema)
            return True
        except jsonschema.ValidationError as e:
            print(f"Protocol validation error: {e.message}", file=sys.stderr)
            return False
    
    def transpile(self, yaml_path: Path) -> Optional[str]:
        """Transpile YAML protocol to Python test harness."""
        # Load YAML protocol
        with open(yaml_path, 'r') as f:
            protocol = yaml.safe_load(f)
        
        # Validate protocol
        if not self.validate_protocol(protocol):
            return None
        
        # Generate Python code
        python_code = self._generate_python_harness(protocol)
        
        # Write output file
        output_path = self.config.output_dir / f"{protocol['meta']['id'].lower()}_harness.py"
        with open(output_path, 'w') as f:
            f.write(python_code)
        
        return str(output_path)
    
    def _generate_python_harness(self, protocol: Dict[str, Any]) -> str:
        """Generate Python test harness from protocol."""
        meta = protocol['meta']
        study = protocol['study']
        population = protocol['population']
        endpoints = protocol['endpoints']
        design = protocol['design']
        
        # Build Python class
        class_name = meta['id'].replace('-', '_')
        
        code_parts = [
            self._generate_header(meta),
            self._generate_imports(),
            self._generate_trial_class(class_name, protocol),
            self._generate_power_analysis_method(design['power_analysis']),
            self._generate_enrollment_simulation(population),
            self._generate_endpoint_validation(endpoints),
            self._generate_compliance_checks(protocol.get('compliance', {})),
            self._generate_main_function(class_name)
        ]
        
        return '\n\n'.join(code_parts)
    
    def _generate_header(self, meta: Dict[str, Any]) -> str:
        """Generate file header with metadata."""
        return f'''"""
{meta['title']}
Protocol ID: {meta['id']}
Version: {meta['version']}
Sponsor: {meta['sponsor']}

Generated by Bastion λ-Trial Transpiler
This file contains the executable test harness for protocol validation,
simulation, and compliance checking.
"""'''
    
    def _generate_imports(self) -> str:
        """Generate import statements."""
        return '''import numpy as np
import pandas as pd
import scipy.stats as stats
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging

# Bastion clinical trial framework
from bastion.core import TrialSimulator, PowerAnalyzer, ComplianceValidator
from bastion.endpoints import EndpointEvaluator
from bastion.safety import SafetyMonitor
from bastion.diversity import DiversityCalculator'''
    
    def _generate_trial_class(self, class_name: str, protocol: Dict[str, Any]) -> str:
        """Generate main trial class."""
        meta = protocol['meta']
        population = protocol['population']
        
        return f'''class {class_name}Trial:
    """
    Executable test harness for {meta['title']}.
    
    This class provides methods for:
    - Statistical power analysis
    - Enrollment simulation
    - Endpoint validation
    - Regulatory compliance checking
    """
    
    def __init__(self):
        self.protocol_id = "{meta['id']}"
        self.protocol_version = "{meta['version']}"
        self.target_enrollment = {population['target_size']}
        self.alpha = {protocol['design']['power_analysis']['alpha']}
        self.power = {protocol['design']['power_analysis']['power']}
        
        # Initialize components
        self.simulator = TrialSimulator()
        self.power_analyzer = PowerAnalyzer()
        self.compliance_validator = ComplianceValidator()
        self.safety_monitor = SafetyMonitor()
        self.diversity_calculator = DiversityCalculator()
        
        # Setup logging
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(f"bastion.{{self.protocol_id}}")'''
    
    def _generate_power_analysis_method(self, power_config: Dict[str, Any]) -> str:
        """Generate power analysis method."""
        return f'''    def run_power_analysis(self, effect_size: float = {power_config['effect_size']}) -> Dict[str, float]:
        """
        Run statistical power analysis for the trial.
        
        Args:
            effect_size: Expected effect size
            
        Returns:
            Dictionary with power analysis results
        """
        results = self.power_analyzer.calculate_power(
            alpha=self.alpha,
            effect_size=effect_size,
            sample_size=self.target_enrollment,
            test_type="{power_config.get('test', 't_test')}"
        )
        
        self.logger.info(f"Power analysis completed: {{results['power']:.3f}}")
        return results'''
    
    def _generate_enrollment_simulation(self, population: Dict[str, Any]) -> str:
        """Generate enrollment simulation method."""
        return f'''    def simulate_enrollment(self, duration_months: int = 12) -> pd.DataFrame:
        """
        Simulate patient enrollment over time.
        
        Args:
            duration_months: Enrollment period in months
            
        Returns:
            DataFrame with simulated enrollment data
        """
        enrollment_data = self.simulator.simulate_enrollment(
            target_size=self.target_enrollment,
            duration_months=duration_months,
            inclusion_criteria={population['inclusion']},
            exclusion_criteria={population.get('exclusion', [])}
        )
        
        # Calculate diversity metrics
        diversity_score = self.diversity_calculator.calculate_diversity(enrollment_data)
        self.logger.info(f"Simulated enrollment diversity score: {{diversity_score:.2f}}")
        
        return enrollment_data'''
    
    def _generate_endpoint_validation(self, endpoints: Dict[str, Any]) -> str:
        """Generate endpoint validation method."""
        primary_endpoints = endpoints['primary']
        endpoint_names = [ep['name'] for ep in primary_endpoints]
        
        return f'''    def validate_endpoints(self, trial_data: pd.DataFrame) -> Dict[str, bool]:
        """
        Validate trial endpoints against protocol specifications.
        
        Args:
            trial_data: Trial data for endpoint evaluation
            
        Returns:
            Dictionary with validation results for each endpoint
        """
        endpoint_evaluator = EndpointEvaluator()
        
        # Primary endpoints
        primary_results = {{}}
        for endpoint_name in {endpoint_names}:
            result = endpoint_evaluator.evaluate_endpoint(
                data=trial_data,
                endpoint_name=endpoint_name,
                endpoint_type="primary"
            )
            primary_results[endpoint_name] = result
            
        self.logger.info(f"Primary endpoint validation completed")
        return primary_results'''
    
    def _generate_compliance_checks(self, compliance: Dict[str, Any]) -> str:
        """Generate regulatory compliance checking method."""
        return f'''    def check_compliance(self) -> Dict[str, bool]:
        """
        Check regulatory compliance requirements.
        
        Returns:
            Dictionary with compliance status for each requirement
        """
        compliance_results = {{}}
        
        # GCP compliance
        if {compliance.get('gcp', False)}:
            compliance_results['gcp'] = self.compliance_validator.check_gcp_compliance()
            
        # Part 11 compliance
        if {compliance.get('part11', False)}:
            compliance_results['part11'] = self.compliance_validator.check_part11_compliance()
            
        # HIPAA compliance  
        if {compliance.get('hipaa', False)}:
            compliance_results['hipaa'] = self.compliance_validator.check_hipaa_compliance()
            
        # GDPR compliance
        if {compliance.get('gdpr', False)}:
            compliance_results['gdpr'] = self.compliance_validator.check_gdpr_compliance()
        
        self.logger.info(f"Compliance checks completed: {{compliance_results}}")
        return compliance_results'''
    
    def _generate_main_function(self, class_name: str) -> str:
        """Generate main execution function."""
        return f'''def main():
    """Main execution function for protocol validation and simulation."""
    trial = {class_name}Trial()
    
    print(f"Running {class_name} Protocol Validation...")
    print(f"Protocol ID: {{trial.protocol_id}}")
    print(f"Version: {{trial.protocol_version}}")
    print(f"Target Enrollment: {{trial.target_enrollment}}")
    
    # Run power analysis
    power_results = trial.run_power_analysis()
    print(f"Power Analysis: {{power_results['power']:.3f}}")
    
    # Simulate enrollment
    enrollment_data = trial.simulate_enrollment()
    print(f"Enrollment Simulation: {{len(enrollment_data)}} patients simulated")
    
    # Validate endpoints (with mock data)
    mock_trial_data = trial.simulator.generate_mock_trial_data(enrollment_data)
    endpoint_results = trial.validate_endpoints(mock_trial_data)
    print(f"Endpoint Validation: {{len(endpoint_results)}} endpoints evaluated")
    
    # Check compliance
    compliance_results = trial.check_compliance()
    print(f"Compliance Check: {{sum(compliance_results.values())}}/{{len(compliance_results)}} requirements met")
    
    print("Protocol validation completed successfully!")

if __name__ == "__main__":
    main()'''

def main():
    """Main CLI function."""
    parser = argparse.ArgumentParser(description="Bastion λ-Trial YAML-to-Python Transpiler")
    parser.add_argument("input", type=Path, help="Input YAML protocol file")
    parser.add_argument("-o", "--output", type=Path, default=Path("./output"), 
                       help="Output directory for generated Python files")
    parser.add_argument("-s", "--schema", type=Path, default=Path("schemas/protocol.schema.json"),
                       help="JSON schema file for validation")
    parser.add_argument("--no-tests", action="store_true", help="Skip test generation")
    parser.add_argument("--no-validation", action="store_true", help="Skip validation checks")
    parser.add_argument("--no-simulation", action="store_true", help="Skip simulation code")
    
    args = parser.parse_args()
    
    # Create configuration
    config = TranspilerConfig(
        schema_path=args.schema,
        output_dir=args.output,
        include_tests=not args.no_tests,
        include_validation=not args.no_validation,
        include_simulation=not args.no_simulation
    )
    
    # Ensure output directory exists
    config.output_dir.mkdir(parents=True, exist_ok=True)
    
    # Create transpiler and run
    transpiler = ProtocolTranspiler(config)
    output_file = transpiler.transpile(args.input)
    
    if output_file:
        print(f"Successfully transpiled {args.input} to {output_file}")
    else:
        print("Transpilation failed!", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()